<!-- Copyright 2020 Rohit Goswami <rog32@hi.is>
     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at
     http://www.apache.org/licenses/LICENSE-2.0
     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License. -->
<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SymEngine C++ API: /home/runner/work/symengine/symengine/symengine/symengine_casts.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  },
  svg: {
    fontCache: 'global'
  }
  loader: { load: ["[tex]/unicode", "[tex]/ams"] },
  tex: {
    packages: { "[+]": ["unicode", "ams"] },
    tags: "ams",
  },
};
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>
<!-- <link href="doxygen.css" rel="stylesheet" type="text/css" /> -->
<link href="doxyYoda.min.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" >
$(document).ready(function() {
     $(".fragment").wrap("<details class='code-details'></details>");
     $(".code-details").append("<summary>Code</summary>");
 }
)
</script>
</head>
<body>
<div class="grid-contents">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<nav class="title_area">
<span class="project_info">SymEngine C++ API </span>
</nav>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_5f3c0b4b33d21f966cb3219df2063971.html">symengine</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle"><div class="title">symengine_casts.h</div></div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a id="l00001" name="l00001"></a><span class="lineno">    1</span><span class="preprocessor">#ifndef SYMENGINE_CASTS_H</span></div>
<div class="line"><a id="l00002" name="l00002"></a><span class="lineno">    2</span><span class="preprocessor">#define SYMENGINE_CASTS_H</span></div>
<div class="line"><a id="l00003" name="l00003"></a><span class="lineno">    3</span> </div>
<div class="line"><a id="l00004" name="l00004"></a><span class="lineno">    4</span><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><a id="l00005" name="l00005"></a><span class="lineno">    5</span><span class="preprocessor">#include &lt;limits&gt;</span></div>
<div class="line"><a id="l00006" name="l00006"></a><span class="lineno">    6</span><span class="preprocessor">#include &lt;symengine/symengine_config.h&gt;</span></div>
<div class="line"><a id="l00007" name="l00007"></a><span class="lineno">    7</span><span class="preprocessor">#include &lt;symengine/symengine_assert.h&gt;</span></div>
<div class="line"><a id="l00008" name="l00008"></a><span class="lineno">    8</span> </div>
<div class="line"><a id="l00009" name="l00009"></a><span class="lineno">    9</span><span class="keyword">namespace </span><a class="code hl_namespace" href="namespaceSymEngine.html">SymEngine</a></div>
<div class="line"><a id="l00010" name="l00010"></a><span class="lineno">   10</span>{</div>
<div class="line"><a id="l00011" name="l00011"></a><span class="lineno">   11</span> </div>
<div class="line"><a id="l00012" name="l00012"></a><span class="lineno">   12</span><span class="comment">// Reference modifications.</span></div>
<div class="line"><a id="l00013" name="l00013"></a><span class="lineno">   13</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><a id="l00014" name="l00014"></a><span class="lineno"><a class="line" href="structSymEngine_1_1remove__reference.html">   14</a></span><span class="keyword">struct </span><a class="code hl_struct" href="structSymEngine_1_1remove__reference.html">remove_reference</a> {</div>
<div class="line"><a id="l00015" name="l00015"></a><span class="lineno">   15</span>    <span class="keyword">typedef</span> T type;</div>
<div class="line"><a id="l00016" name="l00016"></a><span class="lineno">   16</span>};</div>
<div class="line"><a id="l00017" name="l00017"></a><span class="lineno">   17</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><a id="l00018" name="l00018"></a><span class="lineno"><a class="line" href="structSymEngine_1_1remove__reference_3_01T_01_6_01_4.html">   18</a></span><span class="keyword">struct </span><a class="code hl_struct" href="structSymEngine_1_1remove__reference.html">remove_reference</a>&lt;T &amp;&gt; {</div>
<div class="line"><a id="l00019" name="l00019"></a><span class="lineno">   19</span>    <span class="keyword">typedef</span> T type;</div>
<div class="line"><a id="l00020" name="l00020"></a><span class="lineno">   20</span>};</div>
<div class="line"><a id="l00021" name="l00021"></a><span class="lineno">   21</span> </div>
<div class="line"><a id="l00022" name="l00022"></a><span class="lineno">   22</span><span class="comment">// Use implicit_cast as a safe version of static_cast or const_cast</span></div>
<div class="line"><a id="l00023" name="l00023"></a><span class="lineno">   23</span><span class="comment">// for upcasting in the type hierarchy (i.e. casting a pointer to Foo</span></div>
<div class="line"><a id="l00024" name="l00024"></a><span class="lineno">   24</span><span class="comment">// to a pointer to SuperclassOfFoo or casting a pointer to Foo to</span></div>
<div class="line"><a id="l00025" name="l00025"></a><span class="lineno">   25</span><span class="comment">// a const pointer to Foo).</span></div>
<div class="line"><a id="l00026" name="l00026"></a><span class="lineno">   26</span><span class="comment">// When you use implicit_cast, the compiler checks that the cast is safe.</span></div>
<div class="line"><a id="l00027" name="l00027"></a><span class="lineno">   27</span><span class="comment">// Such explicit implicit_casts are necessary in surprisingly many</span></div>
<div class="line"><a id="l00028" name="l00028"></a><span class="lineno">   28</span><span class="comment">// situations where C++ demands an exact type match instead of an</span></div>
<div class="line"><a id="l00029" name="l00029"></a><span class="lineno">   29</span><span class="comment">// argument type convertable to a target type.</span></div>
<div class="line"><a id="l00030" name="l00030"></a><span class="lineno">   30</span><span class="comment">//</span></div>
<div class="line"><a id="l00031" name="l00031"></a><span class="lineno">   31</span><span class="comment">// The From type can be inferred, so the preferred syntax for using</span></div>
<div class="line"><a id="l00032" name="l00032"></a><span class="lineno">   32</span><span class="comment">// implicit_cast is the same as for static_cast etc.:</span></div>
<div class="line"><a id="l00033" name="l00033"></a><span class="lineno">   33</span><span class="comment">//</span></div>
<div class="line"><a id="l00034" name="l00034"></a><span class="lineno">   34</span><span class="comment">//   implicit_cast&lt;ToType&gt;(expr)</span></div>
<div class="line"><a id="l00035" name="l00035"></a><span class="lineno">   35</span> </div>
<div class="line"><a id="l00036" name="l00036"></a><span class="lineno">   36</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> To, <span class="keyword">typename</span> From&gt;</div>
<div class="line"><a id="l00037" name="l00037"></a><span class="lineno">   37</span><span class="keyword">inline</span> To implicit_cast(<span class="keyword">const</span> From &amp;f)</div>
<div class="line"><a id="l00038" name="l00038"></a><span class="lineno">   38</span>{</div>
<div class="line"><a id="l00039" name="l00039"></a><span class="lineno">   39</span>    <span class="keywordflow">return</span> f;</div>
<div class="line"><a id="l00040" name="l00040"></a><span class="lineno">   40</span>}</div>
<div class="line"><a id="l00041" name="l00041"></a><span class="lineno">   41</span> </div>
<div class="line"><a id="l00042" name="l00042"></a><span class="lineno">   42</span><span class="comment">// When you upcast (that is, cast a pointer from type Foo to type</span></div>
<div class="line"><a id="l00043" name="l00043"></a><span class="lineno">   43</span><span class="comment">// SuperclassOfFoo), it&#39;s fine to use implicit_cast&lt;&gt;, since upcasts</span></div>
<div class="line"><a id="l00044" name="l00044"></a><span class="lineno">   44</span><span class="comment">// always succeed.  When you downcast (that is, cast a pointer from</span></div>
<div class="line"><a id="l00045" name="l00045"></a><span class="lineno">   45</span><span class="comment">// type Foo to type SubclassOfFoo), static_cast&lt;&gt; isn&#39;t safe, because</span></div>
<div class="line"><a id="l00046" name="l00046"></a><span class="lineno">   46</span><span class="comment">// how do you know the pointer is really of type SubclassOfFoo?  It</span></div>
<div class="line"><a id="l00047" name="l00047"></a><span class="lineno">   47</span><span class="comment">// could be a bare Foo, or of type DifferentSubclassOfFoo.  Thus,</span></div>
<div class="line"><a id="l00048" name="l00048"></a><span class="lineno">   48</span><span class="comment">// when you downcast, you should use this macro.  In debug mode, we</span></div>
<div class="line"><a id="l00049" name="l00049"></a><span class="lineno">   49</span><span class="comment">// use dynamic_cast&lt;&gt; to double-check the downcast is legal (we die</span></div>
<div class="line"><a id="l00050" name="l00050"></a><span class="lineno">   50</span><span class="comment">// if it&#39;s not).  In normal mode, we do the efficient static_cast&lt;&gt;</span></div>
<div class="line"><a id="l00051" name="l00051"></a><span class="lineno">   51</span><span class="comment">// instead.  Thus, it&#39;s important to test in debug mode to make sure</span></div>
<div class="line"><a id="l00052" name="l00052"></a><span class="lineno">   52</span><span class="comment">// the cast is legal!</span></div>
<div class="line"><a id="l00053" name="l00053"></a><span class="lineno">   53</span><span class="comment">//    This is the only place in the code we should use dynamic_cast&lt;&gt;.</span></div>
<div class="line"><a id="l00054" name="l00054"></a><span class="lineno">   54</span><span class="comment">// In particular, you SHOULDN&#39;T be using dynamic_cast&lt;&gt; in order to</span></div>
<div class="line"><a id="l00055" name="l00055"></a><span class="lineno">   55</span><span class="comment">// do RTTI (eg code like this:</span></div>
<div class="line"><a id="l00056" name="l00056"></a><span class="lineno">   56</span><span class="comment">//    if (dynamic_cast&lt;Subclass1&gt;(foo)) HandleASubclass1Object(foo);</span></div>
<div class="line"><a id="l00057" name="l00057"></a><span class="lineno">   57</span><span class="comment">//    if (dynamic_cast&lt;Subclass2&gt;(foo)) HandleASubclass2Object(foo);</span></div>
<div class="line"><a id="l00058" name="l00058"></a><span class="lineno">   58</span><span class="comment">// You should design the code some other way not to need this.</span></div>
<div class="line"><a id="l00059" name="l00059"></a><span class="lineno">   59</span> </div>
<div class="line"><a id="l00060" name="l00060"></a><span class="lineno">   60</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> To, <span class="keyword">typename</span> From&gt; <span class="comment">// use like this: down_cast&lt;T*&gt;(foo).</span></div>
<div class="line"><a id="l00061" name="l00061"></a><span class="lineno">   61</span><span class="keyword">inline</span> To down_cast(From *f)          <span class="comment">// Only accept pointers.</span></div>
<div class="line"><a id="l00062" name="l00062"></a><span class="lineno">   62</span>{</div>
<div class="line"><a id="l00063" name="l00063"></a><span class="lineno">   63</span>    <span class="comment">// Ensures that To is a sub-type of From *.  This test is here only</span></div>
<div class="line"><a id="l00064" name="l00064"></a><span class="lineno">   64</span>    <span class="comment">// for compile-time type checking, and has no overhead in an</span></div>
<div class="line"><a id="l00065" name="l00065"></a><span class="lineno">   65</span>    <span class="comment">// optimized build at run-time, as it will be optimized away</span></div>
<div class="line"><a id="l00066" name="l00066"></a><span class="lineno">   66</span>    <span class="comment">// completely.</span></div>
<div class="line"><a id="l00067" name="l00067"></a><span class="lineno">   67</span>    <span class="keywordflow">if</span> (<span class="keyword">false</span>) {</div>
<div class="line"><a id="l00068" name="l00068"></a><span class="lineno">   68</span>        implicit_cast&lt;From *, To&gt;(0);</div>
<div class="line"><a id="l00069" name="l00069"></a><span class="lineno">   69</span>    }</div>
<div class="line"><a id="l00070" name="l00070"></a><span class="lineno">   70</span> </div>
<div class="line"><a id="l00071" name="l00071"></a><span class="lineno">   71</span>    SYMENGINE_ASSERT(f == NULL || <span class="keyword">dynamic_cast&lt;</span>To<span class="keyword">&gt;</span>(f) != NULL);</div>
<div class="line"><a id="l00072" name="l00072"></a><span class="lineno">   72</span> </div>
<div class="line"><a id="l00073" name="l00073"></a><span class="lineno">   73</span>    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>To<span class="keyword">&gt;</span>(f);</div>
<div class="line"><a id="l00074" name="l00074"></a><span class="lineno">   74</span>}</div>
<div class="line"><a id="l00075" name="l00075"></a><span class="lineno">   75</span> </div>
<div class="line"><a id="l00076" name="l00076"></a><span class="lineno">   76</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> To, <span class="keyword">typename</span> From&gt; <span class="comment">// use like this: down_cast&lt;T&amp;&gt;(foo);</span></div>
<div class="line"><a id="l00077" name="l00077"></a><span class="lineno">   77</span><span class="keyword">inline</span> To down_cast(From &amp;f)</div>
<div class="line"><a id="l00078" name="l00078"></a><span class="lineno">   78</span>{</div>
<div class="line"><a id="l00079" name="l00079"></a><span class="lineno">   79</span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> remove_reference&lt;To&gt;::type *ToAsPointer;</div>
<div class="line"><a id="l00080" name="l00080"></a><span class="lineno">   80</span>    <span class="comment">// Ensures that To is a sub-type of From *.  This test is here only</span></div>
<div class="line"><a id="l00081" name="l00081"></a><span class="lineno">   81</span>    <span class="comment">// for compile-time type checking, and has no overhead in an</span></div>
<div class="line"><a id="l00082" name="l00082"></a><span class="lineno">   82</span>    <span class="comment">// optimized build at run-time, as it will be optimized away</span></div>
<div class="line"><a id="l00083" name="l00083"></a><span class="lineno">   83</span>    <span class="comment">// completely.</span></div>
<div class="line"><a id="l00084" name="l00084"></a><span class="lineno">   84</span>    <span class="keywordflow">if</span> (<span class="keyword">false</span>) {</div>
<div class="line"><a id="l00085" name="l00085"></a><span class="lineno">   85</span>        implicit_cast&lt;From *, ToAsPointer&gt;(0);</div>
<div class="line"><a id="l00086" name="l00086"></a><span class="lineno">   86</span>    }</div>
<div class="line"><a id="l00087" name="l00087"></a><span class="lineno">   87</span> </div>
<div class="line"><a id="l00088" name="l00088"></a><span class="lineno">   88</span>    SYMENGINE_ASSERT(<span class="keyword">dynamic_cast&lt;</span>ToAsPointer<span class="keyword">&gt;</span>(&amp;f) != NULL);</div>
<div class="line"><a id="l00089" name="l00089"></a><span class="lineno">   89</span> </div>
<div class="line"><a id="l00090" name="l00090"></a><span class="lineno">   90</span>    <span class="keywordflow">return</span> *<span class="keyword">static_cast&lt;</span>ToAsPointer<span class="keyword">&gt;</span>(&amp;f);</div>
<div class="line"><a id="l00091" name="l00091"></a><span class="lineno">   91</span>}</div>
<div class="line"><a id="l00092" name="l00092"></a><span class="lineno">   92</span> </div>
<div class="line"><a id="l00093" name="l00093"></a><span class="lineno">   93</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> To, <span class="keyword">typename</span> From&gt;</div>
<div class="line"><a id="l00094" name="l00094"></a><span class="lineno">   94</span><span class="keyword">inline</span> To numeric_cast(</div>
<div class="line"><a id="l00095" name="l00095"></a><span class="lineno">   95</span>    From f,</div>
<div class="line"><a id="l00096" name="l00096"></a><span class="lineno">   96</span>    <span class="keyword">typename</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/enable_if.html">std::enable_if</a>&lt;</div>
<div class="line"><a id="l00097" name="l00097"></a><span class="lineno">   97</span>        (<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_signed.html">std::is_signed&lt;From&gt;::value</a> &amp;&amp; <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_signed.html">std::is_signed&lt;To&gt;::value</a>)</div>
<div class="line"><a id="l00098" name="l00098"></a><span class="lineno">   98</span>        || (<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_unsigned.html">std::is_unsigned&lt;From&gt;::value</a> &amp;&amp; <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_unsigned.html">std::is_unsigned&lt;To&gt;::value</a>)&gt;::type</div>
<div class="line"><a id="l00099" name="l00099"></a><span class="lineno">   99</span>        * = <span class="keyword">nullptr</span>)</div>
<div class="line"><a id="l00100" name="l00100"></a><span class="lineno">  100</span>{</div>
<div class="line"><a id="l00101" name="l00101"></a><span class="lineno">  101</span>    SYMENGINE_ASSERT(f &lt;= <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits&lt;To&gt;::max</a>());</div>
<div class="line"><a id="l00102" name="l00102"></a><span class="lineno">  102</span>    SYMENGINE_ASSERT(f &gt;= <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits&lt;To&gt;::min</a>());</div>
<div class="line"><a id="l00103" name="l00103"></a><span class="lineno">  103</span>    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>To<span class="keyword">&gt;</span>(f);</div>
<div class="line"><a id="l00104" name="l00104"></a><span class="lineno">  104</span>}</div>
<div class="line"><a id="l00105" name="l00105"></a><span class="lineno">  105</span> </div>
<div class="line"><a id="l00106" name="l00106"></a><span class="lineno">  106</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> To, <span class="keyword">typename</span> From&gt;</div>
<div class="line"><a id="l00107" name="l00107"></a><span class="lineno">  107</span><span class="keyword">inline</span> To numeric_cast(</div>
<div class="line"><a id="l00108" name="l00108"></a><span class="lineno">  108</span>    From f,</div>
<div class="line"><a id="l00109" name="l00109"></a><span class="lineno">  109</span>    <span class="keyword">typename</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/enable_if.html">std::enable_if</a>&lt;(<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_signed.html">std::is_signed&lt;From&gt;::value</a></div>
<div class="line"><a id="l00110" name="l00110"></a><span class="lineno">  110</span>                             &amp;&amp; <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_unsigned.html">std::is_unsigned&lt;To&gt;::value</a>)&gt;::type * = <span class="keyword">nullptr</span>)</div>
<div class="line"><a id="l00111" name="l00111"></a><span class="lineno">  111</span>{</div>
<div class="line"><a id="l00112" name="l00112"></a><span class="lineno">  112</span><span class="preprocessor">#ifdef WITH_SYMENGINE_ASSERT</span></div>
<div class="line"><a id="l00113" name="l00113"></a><span class="lineno">  113</span>    <span class="comment">// Above ifdef is needed to avoid a warning about unused typedefs</span></div>
<div class="line"><a id="l00114" name="l00114"></a><span class="lineno">  114</span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/make_unsigned.html">std::make_unsigned&lt;From&gt;::type</a> unsigned_from_type;</div>
<div class="line"><a id="l00115" name="l00115"></a><span class="lineno">  115</span>    SYMENGINE_ASSERT(f &gt;= 0);</div>
<div class="line"><a id="l00116" name="l00116"></a><span class="lineno">  116</span>    SYMENGINE_ASSERT(<span class="keyword">static_cast&lt;</span>unsigned_from_type<span class="keyword">&gt;</span>(f)</div>
<div class="line"><a id="l00117" name="l00117"></a><span class="lineno">  117</span>                     &lt;= <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits&lt;To&gt;::max</a>());</div>
<div class="line"><a id="l00118" name="l00118"></a><span class="lineno">  118</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00119" name="l00119"></a><span class="lineno">  119</span>    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>To<span class="keyword">&gt;</span>(f);</div>
<div class="line"><a id="l00120" name="l00120"></a><span class="lineno">  120</span>}</div>
<div class="line"><a id="l00121" name="l00121"></a><span class="lineno">  121</span> </div>
<div class="line"><a id="l00122" name="l00122"></a><span class="lineno">  122</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> To, <span class="keyword">typename</span> From&gt;</div>
<div class="line"><a id="l00123" name="l00123"></a><span class="lineno">  123</span><span class="keyword">inline</span> To numeric_cast(</div>
<div class="line"><a id="l00124" name="l00124"></a><span class="lineno">  124</span>    From f,</div>
<div class="line"><a id="l00125" name="l00125"></a><span class="lineno">  125</span>    <span class="keyword">typename</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/enable_if.html">std::enable_if</a>&lt;(<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_unsigned.html">std::is_unsigned&lt;From&gt;::value</a></div>
<div class="line"><a id="l00126" name="l00126"></a><span class="lineno">  126</span>                             &amp;&amp; <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/is_signed.html">std::is_signed&lt;To&gt;::value</a>)&gt;::type * = <span class="keyword">nullptr</span>)</div>
<div class="line"><a id="l00127" name="l00127"></a><span class="lineno">  127</span>{</div>
<div class="line"><a id="l00128" name="l00128"></a><span class="lineno">  128</span><span class="preprocessor">#ifdef WITH_SYMENGINE_ASSERT</span></div>
<div class="line"><a id="l00129" name="l00129"></a><span class="lineno">  129</span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/make_unsigned.html">std::make_unsigned&lt;To&gt;::type</a> unsigned_to_type;</div>
<div class="line"><a id="l00130" name="l00130"></a><span class="lineno">  130</span>    SYMENGINE_ASSERT(</div>
<div class="line"><a id="l00131" name="l00131"></a><span class="lineno">  131</span>        f &lt;= <span class="keyword">static_cast&lt;</span>unsigned_to_type<span class="keyword">&gt;</span>(<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits&lt;To&gt;::max</a>()));</div>
<div class="line"><a id="l00132" name="l00132"></a><span class="lineno">  132</span> </div>
<div class="line"><a id="l00133" name="l00133"></a><span class="lineno">  133</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00134" name="l00134"></a><span class="lineno">  134</span>    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>To<span class="keyword">&gt;</span>(f);</div>
<div class="line"><a id="l00135" name="l00135"></a><span class="lineno">  135</span>}</div>
<div class="line"><a id="l00136" name="l00136"></a><span class="lineno">  136</span> </div>
<div class="line"><a id="l00137" name="l00137"></a><span class="lineno">  137</span>} <span class="comment">// namespace SymEngine</span></div>
<div class="line"><a id="l00138" name="l00138"></a><span class="lineno">  138</span> </div>
<div class="line"><a id="l00139" name="l00139"></a><span class="lineno">  139</span><span class="preprocessor">#endif </span><span class="comment">// SYMENGINE_CASTS_H</span></div>
<div class="ttc" id="aenable_if_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/types/enable_if.html">std::enable_if</a></div></div>
<div class="ttc" id="ais_signed_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/types/is_signed.html">std::is_signed</a></div></div>
<div class="ttc" id="ais_unsigned_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/types/is_unsigned.html">std::is_unsigned</a></div></div>
<div class="ttc" id="amake_unsigned_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/types/make_unsigned.html">std::make_unsigned</a></div></div>
<div class="ttc" id="anamespaceSymEngine_html"><div class="ttname"><a href="namespaceSymEngine.html">SymEngine</a></div><div class="ttdoc">Main namespace for SymEngine package.</div><div class="ttdef"><b>Definition:</b> <a href="add_8cpp_source.html#l00018">add.cpp:19</a></div></div>
<div class="ttc" id="anumeric_limits_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a></div></div>
<div class="ttc" id="astructSymEngine_1_1remove__reference_html"><div class="ttname"><a href="structSymEngine_1_1remove__reference.html">SymEngine::remove_reference</a></div><div class="ttdef"><b>Definition:</b> <a href="symengine__casts_8h_source.html#l00014">symengine_casts.h:14</a></div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- Copyright 2020 Rohit Goswami <rog32@hi.is>
     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at
     http://www.apache.org/licenses/LICENSE-2.0
     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License. -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div class="footer">
<hr class="footline"/><address class="footline"><small>
    Generated by&#160;<a href="https://www.doxygen.org/index.html">Doxygen 1.9.6</a> and the <a class="outlink" href="https://github.com/HaoZeke/doxyYoda">doxyYoda theme</a>
</small></address>
</div>
</div>
</body>
</html>
